# 数据结构学习

==研究如何在程序中存储数字以及使用数字==

不但要知道数字的值，还要知道数字与数字之间的关系

## 数字间的关系

- 现实生活中数字之间的关系叫逻辑关系或==逻辑结构==
  - 集合结构：所有数字可以别看做是一个整体：例如买菜，菜不是一颗一颗卖而是一筐一筐卖，一筐就是一个整体
  - 线性结构：可以用一条有顺序的线把所有数字串起来：公交车的所有站点符合线性结构
  - 树状结构：所有数字从一个数字扩展出来，扩展规则一致：家谱里的每个人之间符合树状结构
  - 网状结构：任何两个数字之间都可以有直接的联系，不同数字之间的联系相护无关：例如铁路网
- 计算机里数字的存储区之间的关系叫物理关系或物理==结构==
  - 顺序结构：数组、动态分配内存
    - 所有存储区连续排列
    - 每个存储区有一个唯一的编号，可以直接根据编号找到存储区（==随机访问能力==），例如找编号为5的存储区不用从0开始找，可以直接定位到5号
    - 缺点：难以调整存储区个数，例如在声明数组式必须定义数据个数，这个个数是死的
    - 缺点：不适合进行插入和删除操作：要进行插入或删除操作时必须对修改位置之前或之后的所有存储区都进行改动

```cpp
 10 20 30 40 50 60 0 0 0
     35//把35插入到30和40之间
```

- 
  - 链式结构
    - 由多个==结构体类型==的存储区构成，这些存储区叫==节点==
    - 这些结构体存储区之间可以用指针建立起互相联系
    - 最简单的链式物理结构是线性链式物理结构（每个节点里只需包含一个指针）
    - 适合进行插入和删除操作
    - 采用动态分配节点就可以自由调整节点个数

> 在C中定义结构体类型变量
>
> struct student{    char no[20];       *//学号*
>
> ​    char name[20];    *//姓名*      
>
>    char sex[5];    *//性别*
>
> ​    int age;          *//年龄* };
>
> ==struct student stu1,stu2;==
>
> 每次定义变量时都要使用struct，一般这样：
>
> typedef struct student{
>     char no[20];       //学号
>     char name[20];    //姓名
>       char sex[5];    //性别
>     int age;          //年龄
> }STUDENT;
> STUDENT stu1;

![](image\屏幕截图 2022-09-22 111640.png)

```c
// 实现一个线性链式物理结构
#include<stdio.h>
typedef struct node{
    int val;	// 用来记录数字
    struct node *p_next;	// 用来指向后一个节点
} node;	//代表线性链式物理结构中节点的结构体
int main(){
    node node1 = {10}, node2 = {20}, node3 = {30};
    node head = {0}/*无效头节点*/, tail = {0}/*无效尾节点*/;
    node *p_tmp = NULL;
    head.p_next = &node1;
    head1.p_next = &node2;
    head2.p_next = &node3;
    head3.p_next = &tail;
    
    // 指针循环变量p_tmp从头节点开始向后一次指向每个节点，知道最后一个有效节点为止
    for(p_tmp = &head; p_tmp != &tail; p_tmp = p_tmp->p_next){
        // 以下三个指针永远指向三个相邻的节点
        // 其中p_first指向其中最前面的节点
        // p_last指向最后面的节点
        node *p_first = p_tmp;
        node *p_mid = p_first->p_next;	//从第一个有效节点一直指向到尾节点
        node *p_last = p_mid->p_next;
    }
    return 0;
}
```

```cpp
// 对线性链式结构进行插入和删除结构
#include<stdio.h>
typedef struct node{
    int val;	// 用来记录数字
    struct node *p_next;	// 用来指向后一个节点
} node;	//代表线性链式物理结构中节点的结构体
int main(){
    node node1 = {10}, node2 = {20}, node3 = {30};
    node node4 = {25};	//想把node4插入到2和3之间
    node head = {0}/*无效头节点*/, tail = {0}/*无效尾节点*/;
    node *p_tmp = NULL;
    head.p_next = &node1;
    head1.p_next = &node2;
    head2.p_next = &node3;
    head3.p_next = &tail;
    
    // 把node4插入到线性链式物理结构中，插入后保持左右数字仍是前小后大
    for(p_tmp = &head; p_tmp != &tail; p_tmp = p_tmp->p_next){
        node *p_first = p_tmp;
        node *p_mid = p_first->p_next;	
        node *p_last = p_mid->p_next;
        if(p_mid == &tail/*node4的值比p_mid里的大p_mid指针指向尾节点*/|| p_mid->val > node4.val/*p_mid指针指向节点里的数字第一次比node4里的数字大*/){
            p_first->p_next = &node4;
            node4.p_next = p_mid;
            break;
        }
    }
    
    // 把20所在的节点从链式结构中删除
    for(p_tmp = &head; p_tmp != &tail; p_tmp = p_tmp->p_next){
        node *p_first = p_tmp;
        node *p_mid = p_first->p_next;	
        node *p_last = p_mid->p_next;
        if(p_mid->val == 20){	
            p_first->p_next = p_last;
            break;
        }
        

    return 0;
}
```

## 数据结构

- 组成
  - 一组存储区：用来存放数字
  - 一组函数：用来操作存储区

实际操作中，数据结构以外的程序不能操作数据结构存储区，必须由数据结构的函数操作

### 栈

- 使用方法
  - 每次只能加入一个数字，每次只能拿出一个数字
  - 栈里的数字有前后顺序，先进入的数字在前，后进入的数字在后
  - 每次从栈里获得的数字一定是最后放进去的数字（==后进先出==）

- 实现方法

```cpp
// stack
// 声明栈结构体
typedef struct{
    int buf[SIZE];	// 定义一个数组用来记录栈里的数字，
                    // SIZE通过宏定义提前定义栈可以存储的最大数字个数
    int qty;	// 记录栈里的实际数字个数
} stack;	// 代表栈的结构体

// 栈管理函数
// 栈的初始化函数：把一个没有使用过的栈设置为可以使用的状态
void stack_init(stack *p_stack){ // 结构体指针形参p_stack代表一个栈
    p_stack->qty = 0;	// 表示栈里没有数字
}

// 栈的清理函数：把一个使用过的栈里的所有数字删除
void stack_deinit(stack *p_stack){
    p_stack->qty = 0;	// 栈里么有数字就相当于删除所有数字
    				   // 清理函数和初始化函数的内容是一样的，但使用场景不同，初始化函数操作一个没有使用过的栈，清理函数操作的是使用过的栈
}

// 获得栈里数字个数的函数
int stack_size(const stack *p_stack){// int类型返回栈数字个数，
    							// const代表这个函数不会修改栈的内容
    return p_stack->qty；
}

// 判断栈是否空的函数
int stack_empty(const stack *p_stack) {//const代表这个函数不会修改栈的内容
    return !p_stack->qty;	// 如果栈是空的则返回真
}

// 判断栈是否满函数
int stack_full(const stack *p_stack) {
    return p_stack->qty >= SIZE；	// 如果SIZE等于qty则说明栈满了，为了保险也考虑大于这种情况
}

// 向栈里加入数字的函数
int stack_push(stack *p_stack, int val) { //因为向栈里加入数字可能失败（栈满了）int返回值用来返回加入数字是否成功
    if (p_stack->qty >= SIZE) {
        // 如果栈已经满了就不可能加入新数字了
        return 0；	// 加入数字失败
    }
    p_stack->buf[p_stack->qty] = val;	// 以qty做下标到数组里找一个存储区把新的数字赋值给这个存储区
    p_stack->qty++;	//栈里的数字个数多了一个
    return 1；	// 加入数字成功
}

// 从栈里获得数字的函数（同时删除栈里的数字）
int stack_pop(stack *stack, int *p_val) { // int返回是否获取成功，int*指针用来返回获得的数据值，**用指针来向调用函数传递数据**
    if (!p_stack->qty) {
        // 如果栈里没有数字就无法获得数字
        return 0；// 获取失败
    }
    // 用指针来向调用函数传递数据
    *p_val = p_stack->buf[p_stack->qty -1];	// 找到qty-1做下标的存储区，它里面就是最后面的数字，把这个数字传递给调用函数
    p_stack->qty--;	// 数字个数减一
    return 1；	// 表示成功获取数字
}

// 从栈里获得数字的函数（但不删除栈里的数字）
int stack_top(const stack *p_stack, int *p_val) { // const表示不修改栈内容
    if (!p_stack->qty) {
        // 如果栈里没有数字就无法获得数字
        return 0；// 获取失败
    }
    *p_val = p_stack->buf[p_stack->qty -1];	// 找到qty-1做下标的存储区，它里面就是最后面的数字，把这个数字传递给调用函数
    return 1；
}
```

对上述栈进行编译检查

```bash
$ gcc -DSIZE=5 -c stack_1.c
```

> -DSIZE表示对宏SIZE进行设置；-c是因为没有主函数 

==预处理指令:==

```cpp
#ifndef				__STACK_1_H__
#define				__STACK_1_H__
...
#endif				// __STACK_1_H__
```

>  把结构体定义和函数声明放在.h文件下，把函数实现放在.c文件下，.c文件要包含.h文件
>
> .h和.c文件在同一个文件夹下时，include用双引号“” 

> 编译多个源文件：每个c文件都要编译下，h文件时包含在c文件中的

```bash
$ gcc -DSIZE=5 stack_1.c stack_main.c
```

### 队列

- 使用方法
  - 每次只能加入一个数字，每次只能拿出一个数字   同栈
  - 栈里的数字有前后顺序，先进入的数字在前，后进入的数字在后   同栈
  - 每次从栈里获得的数字一定是==最先==放进去的数字（==先进先出==）  ==与栈不同点==

- 实现方法

```cpp
// 声明队列结构体
typedef struct {
    int buf[SIZE];	// 记录队列里的数字
    int head;	// 记录第一个数字所在的存储区下标，如果队列为空则head应等于tail
    int tail;	// 记录下一个数字应该放置的下标
} queue;

// 队列初始化函数
void queue_init(queue *P_queue) {
    p_queue->tail = 0;	// 下一个数字应该放置下标为0的存储区里
    p_queue->head = 0;	// head等于tail时表示队列里没有数字
}

// 队列的清理函数
void queue_deinit(queue *P_queue) {
    p_queue->tail = 0;	// 下一个数字应该放置下标为0的存储区里
    p_queue->head = 0;	// head等于tail时表示队列里没有数字
}

// 获得队列数字个数的函数
int queue_size(const stack *p_queue){// int类型返回栈数字个数，
    							// const代表这个函数不会修改栈的内容
    return p_queue->tail - p_queue->head; // tail表示最后一个数字应该放置的下标，head表示第一个数字的下标，相减得到队列数字个数
}

// 判断队列是否为空的函数
int queue_empty(const queue *p_queue) {//const代表这个函数不会修改栈的内容
    return p_queue->tail = p_queue->head ;	// 如果队列为空则head=tai
}

// 判断队列是否满函数
int queue_full(const queue *p_queue) {
    return p_queue->tail >= SIZE；	// 如果SIZE等于tail则说明最后一个存储区已经填上数了，为了保险也考虑大于这种情况
}

// 向队列加入数字的函数
int queue_push(queue *p_queue, int val) { //因为向队列里加入数字可能失败（队列满了）int返回值用来返回加入数字是否成功
    if (p_queue->tail >= SIZE) {
        // 如果栈已经满了就不可能加入新数字了
        return 0；	// 加入数字失败
    }
    p_queue->buf[p_queue->tail] = val;	// 以tail做下标到数组里找一个存储区把新的数字赋值给这个存储区
    p_queue->tail++;	//把tail向后移动一步
    return 1；	// 加入数字成功
}

// 从队列里获得数字的函数（同时删除队列里的数字）
int queue_pop(queue *queue, int *p_val) { // int返回是否获取成功，int*指针用来返回获得的数据值，**用指针来向调用函数传递数据**
    if (p_queue->tail == p_queue->head) {
        // head==tail说明队列是空的
        return 0；// 获取失败
    }
    // 用指针来向调用函数传递数据
    *p_val = p_queue->buf[p_queue->head];	// 把数组里以head做下标的存储区里的数字传递给调用函数
    p_queue->head++;	// 把head向后移动一步，这表示删除这个数字
    return 1；	// 表示成功获取数字
}

// 从队列里获得数字的函数（但不删除队列里的数字）
int queue_top(const queue *p_queue, int *p_val) { // const表示不修改栈内容
    if (p_queue->head == p_queue->tail) {
        // 如果队列里没有数字就无法获得数字
        return 0；// 获取失败
    }
    *p_val = p_queue->buf[p_queue->head];	// 把数组里以head做下标的存储区里的数字传递给调用函数
    return 1；
}
```

### 循环队列

- 当数组里最后一个存储区也被放上数字后可以把后面的数字放在下标为0的存储区里（这个存储区里必须没有有效数字）

- 实现方法

```cpp
// 定义一个循环队列
typedef struct{
    int buf[SIZE];	// 记录数字的数组
    int qty;		// 队列里实际存放 的数字个数
    int tail;		// 下一个数字所在的下标
    				// 没有定义第一个数字的下标，因为它可以通过qty和tail运算出来
} queue;

// 获得第一个数字所在下标的函数
int get_head(const queue *p_queue) {
    int ret  = p_queue->tail - p_queue->qty;
    if (ret < 0) {
        ret +=SIZE; 
        return ret;
    }
}
```

### 链表

- 用来管理线性链式物理功能的数据结构
- 不用每次使用线性链式物理结构时都自己编写代码直接操作存储区
- 链表提供功能来管理线性链式物理结构，只要使用就可以了，不用自己编函数
- 实现方法：

```cpp
// 定义链表物理结构的节点
// 节点有数据和下一个节点数据的地址
typedef struct {
    int val;	// 记录数字的成员变量
    struct node *p_next;	//指向下一个节点的指针
} node;

// 定义链表，链表就是一系列节点
// 由于链表之间的互相指向关系，只要知道了头节点和尾节点就相当于知道了整个链表的数据，因此链表结构里只需要定义头节点和尾节点
typedef struct {
    node head;	// 头节点
    node tail;	// 尾节点
} link;
```

- 链表功能

```cpp
// 链表初始化函数：把一个没有使用过的链表设置为可以使用的状态
void link_init(link *p_link) {
    p_link->head.p_next = &p_link->tail;// 把头节点和尾节点连接起来形成一个空的线性链式物理结构
    // -> 和 . 优先级相同，都是自左至右
    // p_link是指向链表的指针，
    // p_link->head表示用指针访问链表link的成员head，
    // head是node类型的对象，head.p_next是用对象名访问node类型对象head的成员p_next
    // 指针p_next又是node类的成员，它指向的类型也是node！
    // 把链式结构link的为节点的地址赋给p_next指针
    // 综上，链式结构link的头节点head的指针指向了尾节点tail
    p_link->tail.p_next = NULL;// 把尾节点里的指针设置为空指针，否则就是野指针
}

// 链表清理函数：删除链表里的所有数字
void link_deinit(link *p_link) {
    // 初始化时可以把头指向尾生成一个空链表，但释放时不能这样，因为
    // 链表中可能存在动态分配节点，必须把所有的动态分配节点都释放掉
    // 做法：不断释放最前面的有效节点
    node *p_first = NULL, *p_mid = NULL, *p_last = NULL;// 这三个指针是指向node类型的
    // 每次循环把最前面的有效节点删除并释放（头节点和尾节点是无效节点）
    // 由于不知道有多少数据需要循环多少次，适合使用while循环
    // 头节点后面不是尾节点就说明存在有效节点，循环就应该继续
    while (p_link->head.p_next != &p_link->tail) {
        // 让三个结点指针指向链表最前面的三个节点
        // 这三个指针是指向node类型的
        p_first = &p_link->head;
        p_mid = p_first->p_next;	//p_mid就是我们要清理的数字
        						  // p_next成员是个指针，它存的下一个节点的地址，因此这句把次节点的地址传给p_mid
        p_last = p_mid->p_next;      // 把第三个节点的地址传给p_last
        // 把p_mid指针指向的节点从链式物理结构中摘除
        // 直接让p_first指针指向p_last节点，这样p_mid就脱离了链式物理结构，实现了删除
        p_first->p_next = p_last;
        // 释放p_mid指针指向的节点
        free(p_mid);// <stdlib.h>
        p_mid = NULL;// 养成好习惯
    }
}

// 获得数字个数的函数
int link_size(const link *p_link){
    node *p_tmp = NULL;// 指针循环变量
}

```

